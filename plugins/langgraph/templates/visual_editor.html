<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual Workflow Editor - LangGraph</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <!-- Store access token for API calls -->
  <script>
    {% if access_token %}
    localStorage.setItem('access_token', '{{ access_token }}');
    document.cookie = 'access_token={{ access_token }}; path=/; max-age=3600; SameSite=Lax';
    {% endif %}
  </script>

  <style>
    [x-cloak] { display: none !important; }

    #canvas {
      background-image:
        linear-gradient(rgba(0,0,0,.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,.03) 1px, transparent 1px);
      background-size: 20px 20px;
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .node {
      position: absolute;
      cursor: move;
      user-select: none;
      transition: box-shadow 0.2s;
    }

    .node:hover {
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    }

    .node.dragging {
      opacity: 0.8;
      z-index: 1000;
    }

    .connection-port {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      cursor: crosshair;
      transition: all 0.2s;
    }

    .connection-port:hover {
      transform: scale(1.5);
    }

    .connection-line {
      position: absolute;
      pointer-events: none;
      z-index: 0;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }

    .edge-path {
      pointer-events: stroke;
      cursor: pointer;
      transition: stroke-width 0.2s, stroke 0.2s;
    }

    .edge-path:hover {
      stroke: #6366f1 !important;
      stroke-width: 3 !important;
    }

    .edge-path.selected {
      stroke: #ef4444 !important;
      stroke-width: 3 !important;
    }

    .edge-menu {
      position: absolute;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
  </style>
</head>

<body class="h-screen overflow-hidden bg-gray-50">
  <div class="h-full flex flex-col" x-data="visualEditor" @mousemove="onMouseMove" @mouseup="onMouseUp">
    <!-- Toolbar -->
    <div class="bg-white border-b px-4 py-3 flex items-center justify-between shadow-sm z-10">
      <div class="flex items-center space-x-4">
        <a href="/admin/langgraph" class="text-gray-600 hover:text-gray-900">
          <i class="fas fa-arrow-left text-lg"></i>
        </a>
        <input
          type="text"
          x-model="workflow.name"
          class="text-xl font-bold border-none focus:outline-none focus:ring-2 focus:ring-indigo-500 rounded px-2"
          placeholder="Untitled Workflow"
        />
      </div>

      <div class="flex items-center space-x-2">
        <button
          @click="showExecutionPanel = !showExecutionPanel"
          class="px-3 py-2 text-gray-600 hover:bg-gray-100 rounded-lg relative"
          :class="showExecutionPanel ? 'bg-indigo-100 text-indigo-600' : ''"
          title="Toggle execution results"
        >
          <i class="fas fa-chart-line"></i>
          <span x-show="executionResult.logs.length > 0" class="absolute top-1 right-1 w-2 h-2 bg-green-500 rounded-full"></span>
        </button>
        <button
          @click="clearCanvas()"
          class="px-3 py-2 text-gray-600 hover:bg-gray-100 rounded-lg"
          title="Clear canvas"
        >
          <i class="fas fa-trash"></i>
        </button>
        <button
          @click="saveWorkflow()"
          class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center"
        >
          <i class="fas fa-save mr-2"></i>Save
        </button>
        <button
          @click="executeWorkflow()"
          :disabled="nodes.length === 0"
          :class="nodes.length === 0 ? 'opacity-50 cursor-not-allowed' : ''"
          class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center"
        >
          <i class="fas fa-play mr-2"></i>Run
        </button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex overflow-hidden">
      <!-- Sidebar -->
      <div class="w-64 bg-white border-r p-4 overflow-y-auto z-10">
        <h3 class="text-lg font-bold mb-4">Node Library</h3>

        <div class="space-y-2">
          <button
            @click="addNode('llm', 100, 100)"
            class="w-full p-3 bg-purple-50 border-2 border-purple-200 rounded-lg hover:bg-purple-100 flex items-center"
          >
            <div class="w-10 h-10 bg-purple-500 text-white rounded flex items-center justify-center mr-3">
              <i class="fas fa-brain"></i>
            </div>
            <div class="text-left">
              <div class="font-semibold text-sm">LLM Node</div>
              <div class="text-xs text-gray-600">GPT AI</div>
            </div>
          </button>

          <button
            @click="addNode('function', 100, 100)"
            class="w-full p-3 bg-blue-50 border-2 border-blue-200 rounded-lg hover:bg-blue-100 flex items-center"
          >
            <div class="w-10 h-10 bg-blue-500 text-white rounded flex items-center justify-center mr-3">
              <i class="fas fa-code"></i>
            </div>
            <div class="text-left">
              <div class="font-semibold text-sm">Function</div>
              <div class="text-xs text-gray-600">Python</div>
            </div>
          </button>

          <button
            @click="addNode('start', 100, 100)"
            class="w-full p-3 bg-green-50 border-2 border-green-200 rounded-lg hover:bg-green-100 flex items-center"
          >
            <div class="w-10 h-10 bg-green-500 text-white rounded flex items-center justify-center mr-3">
              <i class="fas fa-play"></i>
            </div>
            <div class="text-left">
              <div class="font-semibold text-sm">Start</div>
              <div class="text-xs text-gray-600">Entry</div>
            </div>
          </button>

          <button
            @click="addNode('end', 100, 100)"
            class="w-full p-3 bg-red-50 border-2 border-red-200 rounded-lg hover:bg-red-100 flex items-center"
          >
            <div class="w-10 h-10 bg-red-500 text-white rounded flex items-center justify-center mr-3">
              <i class="fas fa-stop"></i>
            </div>
            <div class="text-left">
              <div class="font-semibold text-sm">End</div>
              <div class="text-xs text-gray-600">Exit</div>
            </div>
          </button>
        </div>

        <div class="mt-6 p-3 bg-blue-50 rounded text-xs text-gray-700">
          <strong>How to use:</strong>
          <ul class="mt-2 space-y-1">
            <li>‚Ä¢ Click buttons to add nodes</li>
            <li>‚Ä¢ Drag nodes to move them</li>
            <li>‚Ä¢ Drag from ‚ö™ to connect</li>
            <li>‚Ä¢ Click ‚öôÔ∏è to configure</li>
            <li>‚Ä¢ Click üóëÔ∏è to delete node + edges</li>
          </ul>
        </div>
      </div>

      <!-- Canvas -->
      <div class="flex-1 relative" :class="showExecutionPanel ? 'mr-96' : ''">
        <div id="canvas" class="absolute inset-0" @click="onEdgeClick($event)">
          <!-- SVG for connections -->
          <svg id="connections-svg">
            <defs>
              <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                <polygon points="0 0, 10 3, 0 6" fill="#94a3b8" />
              </marker>
            </defs>
            <g x-html="renderEdges()"></g>
          </svg>

          <!-- Drawing line -->
          <svg x-show="isDrawingConnection" id="temp-line-svg">
            <line
              :x1="connectionStart.x"
              :y1="connectionStart.y"
              :x2="mousePosition.x"
              :y2="mousePosition.y"
              stroke="#6366f1"
              stroke-width="2"
              stroke-dasharray="5,5"
            />
          </svg>

          <!-- Nodes -->
          <template x-for="node in nodes" :key="node.id">
            <div
              :id="'node-' + node.id"
              class="node bg-white rounded-lg shadow-lg border-2"
              :class="getNodeBorderColor(node.node_type)"
              :style="`left: ${node.position_x}px; top: ${node.position_y}px; width: 220px;`"
              @mousedown="startDrag($event, node)"
              @click="if (!hasDragged) openNodeConfig(node)"
              @contextmenu.prevent="deleteNode(node)"
            >
              <!-- Node Header -->
              <div class="p-3 border-b flex items-center justify-between">
                <div class="flex items-center flex-1 min-w-0">
                  <div
                    class="w-8 h-8 rounded flex items-center justify-center text-white mr-2 flex-shrink-0"
                    :class="getNodeBgColor(node.node_type)"
                  >
                    <i :class="'fas fa-' + getNodeIcon(node.node_type)"></i>
                  </div>
                  <input
                    type="text"
                    x-model="node.label"
                    @click.stop
                    @mousedown.stop
                    class="font-semibold text-sm border-none focus:outline-none focus:ring-1 focus:ring-indigo-500 rounded px-1 flex-1 min-w-0"
                    placeholder="Label"
                  />
                </div>
                <div class="flex items-center space-x-1">
                  <button
                    @click.stop="openNodeConfig(node)"
                    class="text-gray-400 hover:text-indigo-600 p-1 rounded hover:bg-gray-100"
                    title="Configure node"
                  >
                    <i class="fas fa-cog text-sm"></i>
                  </button>
                  <button
                    @click.stop="deleteNode(node)"
                    class="text-gray-400 hover:text-red-600 p-1 rounded hover:bg-red-50"
                    title="Delete node and connections"
                  >
                    <i class="fas fa-trash text-sm"></i>
                  </button>
                </div>
              </div>

              <!-- Node Body -->
              <div class="p-2 text-xs text-gray-600">
                <div class="font-mono text-xs" x-text="node.node_type"></div>
              </div>

              <!-- Connection Ports -->
              <div class="flex justify-between items-center px-3 pb-2">
                <!-- Input Port -->
                <div
                  @mouseup.stop="endConnection(node)"
                  class="connection-port bg-gray-300 hover:bg-green-500"
                  :data-node-id="node.id"
                  title="Input"
                ></div>

                <!-- Output Port -->
                <div
                  @mousedown.stop="startConnection($event, node)"
                  class="connection-port bg-gray-300 hover:bg-blue-500"
                  :data-node-id="node.id"
                  title="Output - drag to connect"
                ></div>
              </div>
            </div>
          </template>

          <!-- Empty state -->
          <div x-show="nodes.length === 0" class="absolute inset-0 flex items-center justify-center pointer-events-none">
            <div class="text-center">
              <i class="fas fa-project-diagram text-6xl text-gray-300 mb-4"></i>
              <h3 class="text-xl font-semibold text-gray-600 mb-2">Click nodes to add them</h3>
              <p class="text-gray-500">Drag to move ‚Ä¢ Drag from ‚ö™ to connect</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Edge Context Menu -->
      <div
        x-show="showEdgeMenu"
        @click.away="hideEdgeMenu()"
        class="edge-menu"
        :style="`left: ${edgeMenuPosition.x}px; top: ${edgeMenuPosition.y}px;`"
      >
        <div class="px-3 py-2 border-b text-xs text-gray-600 font-medium">
          <div x-text="getEdgeDescription(selectedEdge)"></div>
        </div>
        <button
          @click="deleteEdge(selectedEdge)"
          class="w-full px-4 py-2 text-left text-red-600 hover:bg-red-50 flex items-center text-sm"
        >
          <i class="fas fa-trash mr-2"></i>
          Delete Connection
        </button>
      </div>

      <!-- Execution Results Panel -->
      <div
        x-show="showExecutionPanel"
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="translate-x-full"
        x-transition:enter-end="translate-x-0"
        class="fixed right-0 top-0 bottom-0 w-96 bg-white border-l shadow-2xl overflow-hidden flex flex-col z-20"
        style="margin-top: 60px;"
      >
        <!-- Panel Header -->
        <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white p-4 flex items-center justify-between">
          <div class="flex items-center">
            <i class="fas fa-chart-line mr-3 text-xl"></i>
            <h3 class="font-bold text-lg">Execution Results</h3>
          </div>
          <button
            @click="showExecutionPanel = false"
            class="text-white hover:bg-white/20 rounded p-2"
          >
            <i class="fas fa-times"></i>
          </button>
        </div>

        <!-- Execution Status -->
        <div class="p-4 border-b" :class="executionResult.status === 'completed' ? 'bg-green-50' : executionResult.status === 'failed' ? 'bg-red-50' : 'bg-yellow-50'">
          <div class="flex items-center justify-between mb-2">
            <span class="font-semibold text-gray-700">Status:</span>
            <span
              class="px-3 py-1 rounded-full text-sm font-semibold"
              :class="{
                'bg-green-500 text-white': executionResult.status === 'completed',
                'bg-red-500 text-white': executionResult.status === 'failed',
                'bg-yellow-500 text-white': executionResult.status === 'running'
              }"
            >
              <i :class="{
                'fas fa-check-circle': executionResult.status === 'completed',
                'fas fa-times-circle': executionResult.status === 'failed',
                'fas fa-spinner fa-spin': executionResult.status === 'running'
              }" class="mr-1"></i>
              <span x-text="executionResult.status"></span>
            </span>
          </div>
          <template x-if="executionResult.error">
            <div class="mt-2 p-2 bg-red-100 border border-red-300 rounded text-sm text-red-800">
              <i class="fas fa-exclamation-triangle mr-1"></i>
              <span x-text="executionResult.error"></span>
            </div>
          </template>
        </div>

        <!-- Execution Timeline -->
        <div class="flex-1 overflow-y-auto p-4">
          <h4 class="font-semibold text-gray-700 mb-3 flex items-center">
            <i class="fas fa-tasks mr-2"></i>
            Execution Timeline
          </h4>

          <div class="space-y-3">
            <template x-for="(log, index) in executionResult.logs" :key="index">
              <div class="relative pl-6 pb-4 border-l-2" :class="log.error ? 'border-red-400' : 'border-green-400'">
                <!-- Timeline dot -->
                <div
                  class="absolute left-0 top-0 w-4 h-4 rounded-full -ml-2"
                  :class="log.error ? 'bg-red-500' : 'bg-green-500'"
                ></div>

                <!-- Log content -->
                <div class="bg-gray-50 rounded-lg p-3 shadow-sm">
                  <!-- Node info -->
                  <template x-if="log.node_id">
                    <div class="flex items-center justify-between mb-2">
                      <div class="flex items-center">
                        <div
                          class="w-6 h-6 rounded flex items-center justify-center text-white text-xs mr-2"
                          :class="getNodeBgColor(log.node_type || 'default')"
                        >
                          <i :class="'fas fa-' + getNodeIcon(log.node_type || 'circle')"></i>
                        </div>
                        <span class="font-semibold text-sm" x-text="log.label || 'Node'"></span>
                      </div>
                      <span class="text-xs text-gray-500" x-text="formatTimestamp(log.timestamp)"></span>
                    </div>
                  </template>

                  <!-- Message -->
                  <p class="text-sm text-gray-700 mb-1" x-text="log.message"></p>

                  <!-- Output preview -->
                  <template x-if="log.output">
                    <div class="mt-2 p-2 bg-white border border-gray-200 rounded text-xs font-mono">
                      <div class="text-gray-500 mb-1">Output:</div>
                      <div class="text-gray-800 max-h-20 overflow-y-auto" x-text="log.output"></div>
                    </div>
                  </template>

                  <!-- Error details -->
                  <template x-if="log.error">
                    <div class="mt-2 p-2 bg-red-50 border border-red-200 rounded text-xs">
                      <div class="text-red-600 font-semibold mb-1">Error:</div>
                      <div class="text-red-800" x-text="log.error"></div>
                    </div>
                  </template>
                </div>
              </div>
            </template>
          </div>

          <!-- Empty state -->
          <template x-if="!executionResult.logs || executionResult.logs.length === 0">
            <div class="text-center text-gray-400 py-8">
              <i class="fas fa-clipboard-list text-4xl mb-2"></i>
              <p>No execution logs yet</p>
            </div>
          </template>
        </div>

        <!-- Final Output -->
        <template x-if="executionResult.output_data">
          <div class="border-t p-4 bg-gray-50">
            <h4 class="font-semibold text-gray-700 mb-2 flex items-center">
              <i class="fas fa-flag-checkered mr-2"></i>
              Final Output
            </h4>
            <div class="bg-white border border-gray-300 rounded p-3 max-h-40 overflow-y-auto">
              <pre class="text-sm text-gray-800 whitespace-pre-wrap font-mono" x-text="JSON.stringify(executionResult.output_data, null, 2)"></pre>
            </div>
          </div>
        </template>
      </div>
    </div>

    <!-- Config Modal -->
    <div
      x-show="showConfigModal"
      @click.self="showConfigModal = false"
      class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      x-cloak
    >
      <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
        <div class="p-6">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-xl font-bold">Configure Node</h3>
            <button @click="showConfigModal = false" class="text-gray-400 hover:text-gray-600">
              <i class="fas fa-times"></i>
            </button>
          </div>

          <template x-if="currentNode && currentNode.node_type === 'llm'">
            <div class="space-y-4">
              <div>
                <label class="block text-sm font-medium mb-2">Model</label>
                <select x-model="currentNode.config.model" class="w-full px-4 py-2 border rounded-lg">
                  <option value="gpt-4o">GPT-4o</option>
                  <option value="gpt-4o-mini">GPT-4o Mini</option>
                  <option value="gpt-4-turbo">GPT-4 Turbo</option>
                  <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                </select>
              </div>
              <div>
                <label class="block text-sm font-medium mb-2">System Prompt</label>
                <textarea
                  x-model="currentNode.config.system_prompt"
                  rows="4"
                  class="w-full px-4 py-2 border rounded-lg"
                  placeholder="You are a helpful assistant..."
                ></textarea>
              </div>
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label class="block text-sm font-medium mb-2">Temperature</label>
                  <input type="number" x-model.number="currentNode.config.temperature" min="0" max="2" step="0.1" class="w-full px-4 py-2 border rounded-lg" />
                </div>
                <div>
                  <label class="block text-sm font-medium mb-2">Max Tokens</label>
                  <input type="number" x-model.number="currentNode.config.max_tokens" min="1" max="4000" class="w-full px-4 py-2 border rounded-lg" />
                </div>
              </div>
            </div>
          </template>

          <template x-if="currentNode && currentNode.node_type === 'function'">
            <div>
              <label class="block text-sm font-medium mb-2">Python Code</label>
              <textarea
                x-model="currentNode.config.code"
                rows="12"
                class="w-full px-4 py-2 border rounded-lg font-mono text-sm"
                placeholder="# Input: 'input' variable&#10;# Output: set 'output' variable&#10;&#10;output = input.upper()"
              ></textarea>
            </div>
          </template>

          <div class="mt-6 flex justify-end space-x-2">
            <button @click="showConfigModal = false" class="px-4 py-2 border rounded-lg hover:bg-gray-50">
              Cancel
            </button>
            <button @click="showConfigModal = false" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">
              Done
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Execution Input Modal -->
    <div
      x-show="showExecutionModal"
      @click.self="showExecutionModal = false"
      class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      style="display: none;"
    >
      <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">Run Workflow</h3>
        <p class="text-sm text-gray-600 mb-4">Enter the input data for your workflow. This will be passed to the first node.</p>

        <textarea
          x-model="executionInput"
          class="w-full border border-gray-300 rounded-lg p-3 mb-4 font-mono text-sm"
          rows="4"
          placeholder='Enter input text or JSON, e.g., "Hello AI" or {"message": "Hello"}'
        ></textarea>

        <div class="flex justify-end space-x-2">
          <button
            @click="showExecutionModal = false"
            class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg"
          >
            Cancel
          </button>
          <button
            @click="runWorkflowExecution()"
            class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center"
          >
            <i class="fas fa-play mr-2"></i>Execute
          </button>
        </div>
      </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div
      x-show="showDeleteModal"
      @click.self="showDeleteModal = false"
      class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      style="display: none;"
    >
      <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
        <div class="flex items-center mb-4">
          <div class="w-10 h-10 bg-red-100 rounded-full flex items-center justify-center mr-3">
            <i class="fas fa-exclamation-triangle text-red-600"></i>
          </div>
          <h3 class="text-lg font-bold text-red-600">Delete Node</h3>
        </div>

        <p class="text-sm text-gray-700 mb-3">
          Are you sure you want to delete "<span class="font-semibold" x-text="nodeToDelete?.label"></span>"?
        </p>

        <div class="bg-yellow-50 border border-yellow-200 rounded p-3 mb-4">
          <div class="flex items-start">
            <i class="fas fa-info-circle text-yellow-600 mr-2 mt-0.5"></i>
            <div class="text-xs text-gray-700">
              <p class="font-semibold mb-1">This action will:</p>
              <ul class="list-disc ml-4 space-y-1">
                <li>Remove the node from the workflow</li>
                <li>Delete <span class="font-semibold" x-text="countNodeConnections(nodeToDelete)"></span> connected edge(s)</li>
                <li>Cannot be undone</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="flex justify-end space-x-2">
          <button
            @click="showDeleteModal = false; nodeToDelete = null"
            class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg"
          >
            Cancel
          </button>
          <button
            @click="confirmDeleteNode()"
            class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 flex items-center"
          >
            <i class="fas fa-trash mr-2"></i>Delete Node
          </button>
        </div>
      </div>
    </div>

    <!-- Clear Canvas Confirmation Modal -->
    <div
      x-show="showClearModal"
      @click.self="showClearModal = false"
      class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      style="display: none;"
    >
      <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4 text-orange-600">Clear Canvas</h3>
        <p class="text-sm text-gray-600 mb-4">
          Are you sure you want to clear all nodes and connections? This action cannot be undone.
        </p>

        <div class="flex justify-end space-x-2">
          <button
            @click="showClearModal = false"
            class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg"
          >
            Cancel
          </button>
          <button
            @click="confirmClearCanvas()"
            class="px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 flex items-center"
          >
            <i class="fas fa-trash mr-2"></i>Clear All
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast notifications - positioned at bottom to not block buttons -->
  <div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>

  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('visualEditor', () => ({
        // State
        workflow: {
          id: null,
          name: 'Untitled Workflow',
          description: '',
        },
        nodes: [],
        edges: [],

        // Drag state
        isDragging: false,
        draggedNode: null,
        dragOffset: { x: 0, y: 0 },
        dragStartPos: { x: 0, y: 0 },
        hasDragged: false,

        // Connection state
        isDrawingConnection: false,
        connectionStart: { x: 0, y: 0 },
        connectionSourceNode: null,
        mousePosition: { x: 0, y: 0 },

        // UI state
        showConfigModal: false,
        currentNode: null,
        showExecutionModal: false,
        executionInput: '',
        showDeleteModal: false,
        nodeToDelete: null,
        showClearModal: false,
        showExecutionPanel: false,
        executionResult: {
          status: '',
          logs: [],
          output_data: null,
          error: null,
        },
        executingNodeIds: [],
        showEdgeMenu: false,
        selectedEdge: null,
        edgeMenuPosition: { x: 0, y: 0 },

        // Initialize
        async init() {
          const urlParams = new URLSearchParams(window.location.search);
          const workflowId = window.location.pathname.split('/').pop();

          if (workflowId && workflowId !== 'editor') {
            await this.loadWorkflow(workflowId);
          }
        },

        // Node Management
        addNode(type, x = null, y = null) {
          const posX = x !== null ? x : 100 + Math.random() * 200;
          const posY = y !== null ? y : 100 + Math.random() * 200;

          const node = {
            id: 'temp_' + Date.now() + '_' + Math.random(),
            node_type: type,
            label: `${type.charAt(0).toUpperCase() + type.slice(1)} Node`,
            position_x: posX,
            position_y: posY,
            config: this.getDefaultConfig(type),
          };

          this.nodes.push(node);
          this.showToast('Node added', 'success');
        },

        getDefaultConfig(type) {
          switch(type) {
            case 'llm':
              return {
                model: 'gpt-4o-mini',
                system_prompt: 'You are a helpful assistant.',
                temperature: 0.7,
                max_tokens: 1000,
              };
            case 'function':
              return {
                code: '# Input is available as \'input\' variable\n# Set \'output\' variable with your result\n\noutput = input'
              };
            default:
              return {};
          }
        },

        deleteNode(node) {
          this.nodeToDelete = node;
          this.showDeleteModal = true;
        },

        countNodeConnections(node) {
          if (!node) return 0;
          return this.edges.filter(e =>
            e.source_node_id === node.id || e.target_node_id === node.id
          ).length;
        },

        async confirmDeleteNode() {
          if (!this.nodeToDelete) return;

          const nodeId = this.nodeToDelete.id;
          const nodeLabel = this.nodeToDelete.label;
          const workflowId = this.workflow.id;

          // Count connections before deletion
          const connectedEdgesCount = this.countNodeConnections(this.nodeToDelete);

          try {
            // If this is a saved node (not temp), delete it from the server
            if (!nodeId.startsWith('temp_') && workflowId) {
              const res = await fetch(
                `/api/v1/plugins/langgraph/workflows/${workflowId}/nodes/${nodeId}`,
                {
                  method: 'DELETE',
                  headers: this.getAuthHeaders(),
                }
              );

              if (!res.ok) {
                throw new Error('Failed to delete node from server');
              }
            }

            // Also remove all connected edges
            const edgesToDelete = this.edges.filter(e =>
              e.source_node_id === nodeId || e.target_node_id === nodeId
            );

            // Delete saved edges from server
            if (workflowId) {
              for (const edge of edgesToDelete) {
                if (!edge.id.startsWith('temp_edge_')) {
                  try {
                    await fetch(
                      `/api/v1/plugins/langgraph/workflows/${workflowId}/edges/${edge.id}`,
                      {
                        method: 'DELETE',
                        headers: this.getAuthHeaders(),
                      }
                    );
                  } catch (err) {
                    // Edge deletion failed silently
                  }
                }
              }
            }

            // Remove from local arrays
            this.nodes = this.nodes.filter(n => n.id !== nodeId);
            this.edges = this.edges.filter(e =>
              e.source_node_id !== nodeId && e.target_node_id !== nodeId
            );

            // Show success message with details
            const message = connectedEdgesCount > 0
              ? `Deleted "${nodeLabel}" and ${connectedEdgesCount} connection(s)`
              : `Deleted "${nodeLabel}"`;

            this.showToast(message, 'success');
          } catch (error) {
            this.showToast('Failed to delete node: ' + error.message, 'error');
          } finally {
            this.showDeleteModal = false;
            this.nodeToDelete = null;
          }
        },

        openNodeConfig(node) {
          this.currentNode = node;
          this.showConfigModal = true;
        },

        // Drag and Drop
        startDrag(event, node) {
          // Don't drag if clicking on inputs, buttons, or icons
          if (event.target.tagName === 'INPUT' ||
              event.target.tagName === 'TEXTAREA' ||
              event.target.tagName === 'BUTTON' ||
              event.target.tagName === 'I' ||
              event.target.closest('button')) {
            return;
          }

          this.isDragging = true;
          this.draggedNode = node;
          this.hasDragged = false;

          const canvas = document.getElementById('canvas');
          const canvasRect = canvas.getBoundingClientRect();

          this.dragStartPos = {
            x: event.clientX,
            y: event.clientY,
          };

          this.dragOffset = {
            x: event.clientX - canvasRect.left - node.position_x,
            y: event.clientY - canvasRect.top - node.position_y,
          };

          const nodeElement = document.getElementById('node-' + node.id);
          if (nodeElement) {
            nodeElement.classList.add('dragging');
          }
        },

        onMouseMove(event) {
          if (this.isDragging && this.draggedNode) {
            // Check if mouse has moved more than 5px (drag threshold)
            const deltaX = Math.abs(event.clientX - this.dragStartPos.x);
            const deltaY = Math.abs(event.clientY - this.dragStartPos.y);

            if (deltaX > 5 || deltaY > 5) {
              this.hasDragged = true;
            }

            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();

            this.draggedNode.position_x = event.clientX - canvasRect.left - this.dragOffset.x;
            this.draggedNode.position_y = event.clientY - canvasRect.top - this.dragOffset.y;
          } else if (this.isDrawingConnection) {
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();

            this.mousePosition.x = event.clientX - canvasRect.left;
            this.mousePosition.y = event.clientY - canvasRect.top;
          }
        },

        onMouseUp(event) {
          if (this.isDragging && this.draggedNode) {
            const nodeElement = document.getElementById('node-' + this.draggedNode.id);
            if (nodeElement) {
              nodeElement.classList.remove('dragging');
            }
          }

          this.isDragging = false;
          this.draggedNode = null;

          // Reset hasDragged after a short delay to allow click event to check it
          setTimeout(() => {
            this.hasDragged = false;
          }, 10);

          if (this.isDrawingConnection) {
            this.isDrawingConnection = false;
            this.connectionSourceNode = null;
          }
        },

        // Connection Management
        startConnection(event, node) {
          event.stopPropagation();

          this.isDrawingConnection = true;
          this.connectionSourceNode = node;

          const canvas = document.getElementById('canvas');
          const canvasRect = canvas.getBoundingClientRect();
          const nodeElement = document.getElementById('node-' + node.id);
          const nodeRect = nodeElement.getBoundingClientRect();

          // Start from output port (right side of node)
          this.connectionStart.x = nodeRect.right - canvasRect.left;
          this.connectionStart.y = nodeRect.top + nodeRect.height / 2 - canvasRect.top;

          this.mousePosition.x = this.connectionStart.x;
          this.mousePosition.y = this.connectionStart.y;
        },

        endConnection(targetNode) {
          if (!this.isDrawingConnection || !this.connectionSourceNode) {
            return;
          }

          // Don't connect to self
          if (this.connectionSourceNode.id === targetNode.id) {
            this.isDrawingConnection = false;
            this.connectionSourceNode = null;
            return;
          }

          // Check if edge already exists
          const exists = this.edges.some(e =>
            e.source_node_id === this.connectionSourceNode.id &&
            e.target_node_id === targetNode.id
          );

          if (exists) {
            this.showToast('Connection already exists', 'warning');
            this.isDrawingConnection = false;
            this.connectionSourceNode = null;
            return;
          }

          // Create edge
          const edge = {
            id: 'temp_edge_' + Date.now() + '_' + Math.random(),
            source_node_id: this.connectionSourceNode.id,
            target_node_id: targetNode.id,
          };

          this.edges.push(edge);

          this.showToast('Connection created', 'success');

          this.isDrawingConnection = false;
          this.connectionSourceNode = null;
        },

        getEdgePath(edge) {
          const sourceNode = this.nodes.find(n => n.id === edge.source_node_id);
          const targetNode = this.nodes.find(n => n.id === edge.target_node_id);

          if (!sourceNode || !targetNode) return '';

          // Calculate positions (output port of source, input port of target)
          const x1 = sourceNode.position_x + 220; // Node width
          const y1 = sourceNode.position_y + 60;  // Approximate middle
          const x2 = targetNode.position_x;
          const y2 = targetNode.position_y + 60;

          // Create curved path
          const midX = (x1 + x2) / 2;

          return `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
        },

        renderEdges() {
          return this.edges.map(edge => {
            const path = this.getEdgePath(edge);
            if (!path) return '';
            const isSelected = this.selectedEdge && this.selectedEdge.id === edge.id;
            const strokeColor = isSelected ? '#ef4444' : '#94a3b8';
            const strokeWidth = isSelected ? '3' : '2';
            return `<path
              d="${path}"
              stroke="${strokeColor}"
              stroke-width="${strokeWidth}"
              fill="none"
              marker-end="url(#arrowhead)"
              class="edge-path ${isSelected ? 'selected' : ''}"
              data-edge-id="${edge.id}"
              style="pointer-events: stroke; cursor: pointer;"
            />`;
          }).join('');
        },

        onEdgeClick(event) {
          // Check if clicked element is an edge path
          const target = event.target;

          if (target.tagName === 'path' && target.classList.contains('edge-path')) {
            const edgeId = target.getAttribute('data-edge-id');
            const edge = this.edges.find(e => e.id === edgeId);

            if (edge) {
              this.selectedEdge = edge;

              // Get canvas position
              const canvas = document.getElementById('canvas');
              const canvasRect = canvas.getBoundingClientRect();

              // Position menu near click (with some offset to avoid covering the line)
              this.edgeMenuPosition = {
                x: event.clientX - canvasRect.left + 10,
                y: event.clientY - canvasRect.top + 10
              };

              this.showEdgeMenu = true;
              event.stopPropagation();
              return;
            }
          }

          // Click was not on an edge, close menu
          this.hideEdgeMenu();
        },

        hideEdgeMenu() {
          this.showEdgeMenu = false;
          this.selectedEdge = null;
        },

        getEdgeDescription(edge) {
          if (!edge) return '';

          const sourceNode = this.nodes.find(n => n.id === edge.source_node_id);
          const targetNode = this.nodes.find(n => n.id === edge.target_node_id);

          if (!sourceNode || !targetNode) return 'Connection';

          return `${sourceNode.label} ‚Üí ${targetNode.label}`;
        },

        async deleteEdge(edge) {
          if (!edge) return;

          const workflowId = this.workflow.id;

          try {
            // Delete from server if it's a saved edge
            if (!edge.id.startsWith('temp_edge_') && workflowId) {
              const res = await fetch(
                `/api/v1/plugins/langgraph/workflows/${workflowId}/edges/${edge.id}`,
                {
                  method: 'DELETE',
                  headers: this.getAuthHeaders(),
                }
              );

              if (!res.ok) {
                throw new Error('Failed to delete connection from server');
              }
            }

            // Remove from local array
            this.edges = this.edges.filter(e => e.id !== edge.id);

            this.showToast('Connection deleted', 'success');
            this.hideEdgeMenu();
          } catch (error) {
            this.showToast('Failed to delete connection: ' + error.message, 'error');
          }
        },

        // Get auth token from localStorage
        getAuthHeaders() {
          const token = localStorage.getItem('access_token');
          return token ? {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          } : {
            'Content-Type': 'application/json'
          };
        },

        // Workflow Management
        async loadWorkflow(workflowId) {
          try {
            // Load workflow
            const workflowRes = await fetch(`/api/v1/plugins/langgraph/workflows/${workflowId}`, {
              headers: this.getAuthHeaders()
            });
            if (!workflowRes.ok) throw new Error('Failed to load workflow');

            this.workflow = await workflowRes.json();

            // Load nodes
            const nodesRes = await fetch(`/api/v1/plugins/langgraph/workflows/${workflowId}/nodes`, {
              headers: this.getAuthHeaders()
            });
            if (nodesRes.ok) {
              const nodesData = await nodesRes.json();
              this.nodes = nodesData.nodes || [];
            }

            // Load edges
            const edgesRes = await fetch(`/api/v1/plugins/langgraph/workflows/${workflowId}/edges`, {
              headers: this.getAuthHeaders()
            });
            if (edgesRes.ok) {
              const edgesData = await edgesRes.json();
              this.edges = edgesData.edges || [];
            }

            this.showToast('Workflow loaded', 'success');
          } catch (error) {
            this.showToast('Failed to load workflow', 'error');
          }
        },

        async saveWorkflow() {
          try {
            let workflowId = this.workflow.id;

            // Create or update workflow
            if (!workflowId) {
              const res = await fetch('/api/v1/plugins/langgraph/workflows', {
                method: 'POST',
                headers: this.getAuthHeaders(),
                body: JSON.stringify({
                  name: this.workflow.name,
                  description: this.workflow.description,
                }),
              });

              if (!res.ok) throw new Error('Failed to create workflow');

              const data = await res.json();
              workflowId = data.id;
              this.workflow.id = workflowId;

              // Update URL
              window.history.pushState({}, '', `/admin/langgraph/editor/${workflowId}`);
            } else {
              const res = await fetch(`/api/v1/plugins/langgraph/workflows/${workflowId}`, {
                method: 'PUT',
                headers: this.getAuthHeaders(),
                body: JSON.stringify({
                  name: this.workflow.name,
                  description: this.workflow.description,
                }),
              });

              if (!res.ok) throw new Error('Failed to update workflow');
            }

            // Save nodes
            const savedNodes = new Map(); // Map temp IDs to real IDs

            for (const node of this.nodes) {
              if (node.id.startsWith('temp_')) {
                // Create new node
                const res = await fetch(`/api/v1/plugins/langgraph/workflows/${workflowId}/nodes`, {
                  method: 'POST',
                  headers: this.getAuthHeaders(),
                  body: JSON.stringify({
                    workflow_id: workflowId,
                    node_type: node.node_type,
                    label: node.label,
                    position_x: node.position_x,
                    position_y: node.position_y,
                    config: node.config,
                  }),
                });

                if (!res.ok) throw new Error('Failed to create node');

                const data = await res.json();
                savedNodes.set(node.id, data.id);
                node.id = data.id;
              } else {
                // Update existing node
                const res = await fetch(`/api/v1/plugins/langgraph/workflows/${workflowId}/nodes/${node.id}`, {
                  method: 'PUT',
                  headers: this.getAuthHeaders(),
                  body: JSON.stringify({
                    node_type: node.node_type,
                    label: node.label,
                    position_x: node.position_x,
                    position_y: node.position_y,
                    config: node.config,
                  }),
                });

                if (!res.ok) throw new Error('Failed to update node');
              }
            }

            // Save edges
            for (const edge of this.edges) {
              if (edge.id.startsWith('temp_edge_')) {
                // Map temp node IDs to real IDs
                const sourceId = savedNodes.get(edge.source_node_id) || edge.source_node_id;
                const targetId = savedNodes.get(edge.target_node_id) || edge.target_node_id;

                // Create new edge
                const res = await fetch(`/api/v1/plugins/langgraph/workflows/${workflowId}/edges`, {
                  method: 'POST',
                  headers: this.getAuthHeaders(),
                  body: JSON.stringify({
                    workflow_id: workflowId,
                    source_node_id: sourceId,
                    target_node_id: targetId,
                  }),
                });

                if (!res.ok) throw new Error('Failed to create edge');

                const data = await res.json();
                edge.id = data.id;
                edge.source_node_id = sourceId;
                edge.target_node_id = targetId;
              }
            }

            this.showToast('Workflow saved successfully!', 'success');
          } catch (error) {
            this.showToast('Failed to save workflow: ' + error.message, 'error');
          }
        },

        executeWorkflow() {
          if (!this.workflow.id) {
            this.showToast('Please save the workflow first', 'warning');
            return;
          }

          if (this.nodes.length === 0) {
            this.showToast('Add nodes to the workflow first', 'warning');
            return;
          }

          // Show modal to get input
          this.executionInput = '';
          this.showExecutionModal = true;
        },

        async runWorkflowExecution() {
          // Close modal
          this.showExecutionModal = false;

          const input = this.executionInput.trim();

          // Reset execution state
          this.executionResult = {
            status: 'running',
            logs: [],
            output_data: null,
            error: null,
          };
          this.executingNodeIds = [];

          // Show execution panel
          this.showExecutionPanel = true;

          try {
            this.showToast('Executing workflow...', 'info');

            const res = await fetch(`/api/v1/plugins/langgraph/workflows/${this.workflow.id}/execute`, {
              method: 'POST',
              headers: this.getAuthHeaders(),
              body: JSON.stringify({ input: input || '' }),
            });

            if (!res.ok) {
              const error = await res.json();
              const errorMessage = error.detail || 'Execution failed';

              // Update execution result with error
              this.executionResult.status = 'failed';
              this.executionResult.error = errorMessage;

              throw new Error(errorMessage);
            }

            const result = await res.json();

            // Update execution result with success
            this.executionResult.status = result.status;
            this.executionResult.output_data = result.output_data;
            this.executionResult.logs = result.execution_log || [];
            this.executionResult.error = result.error;

            // Highlight nodes that were executed
            this.highlightExecutedNodes(this.executionResult.logs);

            // Show success toast
            if (result.status === 'completed') {
              this.showToast('Execution completed successfully!', 'success', 3000);
            } else if (result.status === 'failed') {
              this.showToast('Execution failed. Check results panel.', 'error', 5000);
            }

          } catch (error) {
            // Update execution result
            this.executionResult.status = 'failed';
            this.executionResult.error = error.message;

            this.showToast('Execution failed: ' + error.message, 'error', 7000);
          }
        },

        highlightExecutedNodes(logs) {
          // Extract node IDs from logs and briefly highlight them
          const nodeIds = logs
            .filter(log => log.node_id)
            .map(log => log.node_id);

          nodeIds.forEach((nodeId, index) => {
            setTimeout(() => {
              const nodeElement = document.getElementById('node-' + nodeId);
              if (nodeElement) {
                nodeElement.classList.add('ring-4', 'ring-green-400');
                setTimeout(() => {
                  nodeElement.classList.remove('ring-4', 'ring-green-400');
                }, 800);
              }
            }, index * 300);
          });
        },

        formatTimestamp(timestamp) {
          if (!timestamp) return '';
          const date = new Date(timestamp);
          return date.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            fractionalSecondDigits: 3
          });
        },

        clearCanvas() {
          this.showClearModal = true;
        },

        confirmClearCanvas() {
          this.nodes = [];
          this.edges = [];
          this.showClearModal = false;
          this.showToast('Canvas cleared', 'info');
        },

        // UI Helpers
        getNodeIcon(type) {
          const icons = {
            llm: 'brain',
            function: 'code',
            start: 'play',
            end: 'stop',
            tool: 'wrench',
            condition: 'code-branch',
          };
          return icons[type] || 'circle';
        },

        getNodeBgColor(type) {
          const colors = {
            llm: 'bg-purple-500',
            function: 'bg-blue-500',
            start: 'bg-green-500',
            end: 'bg-red-500',
            tool: 'bg-yellow-500',
            condition: 'bg-orange-500',
          };
          return colors[type] || 'bg-gray-500';
        },

        getNodeBorderColor(type) {
          const colors = {
            llm: 'border-purple-300',
            function: 'border-blue-300',
            start: 'border-green-300',
            end: 'border-red-300',
            tool: 'border-yellow-300',
            condition: 'border-orange-300',
          };
          return colors[type] || 'border-gray-300';
        },

        showToast(message, type = 'info', duration = 3000) {
          const container = document.getElementById('toast-container');
          const toast = document.createElement('div');

          const colors = {
            success: 'bg-green-500',
            error: 'bg-red-500',
            warning: 'bg-yellow-500',
            info: 'bg-blue-500',
          };

          toast.className = `${colors[type]} text-white px-4 py-3 rounded shadow-lg mb-2`;
          toast.textContent = message;

          container.appendChild(toast);

          setTimeout(() => {
            toast.remove();
          }, duration);
        },
      }));
    });
  </script>
</body>
</html>
